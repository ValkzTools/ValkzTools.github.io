// Disable dragging and resizing during recording
function setOverlayInteraction(enabled) {
  if (enabled) {
    cameraOverlay.style.pointerEvents = "auto";
    cameraOverlay.style.resize = "both";
    cameraOverlay.tabIndex = 0; // make focusable
  } else {
    cameraOverlay.style.pointerEvents = "none";
    cameraOverlay.style.resize = "none";
    cameraOverlay.tabIndex = -1;
  }
}

// Disable dragging flags
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let dragStartLeft = 0;
let dragStartBottom = 0;

// Dragging handlers (only if interaction enabled)
cameraOverlay.addEventListener('mousedown', (e) => {
  if(!cameraOverlay.style.pointerEvents || cameraOverlay.style.pointerEvents === "none") return;
  if(e.target !== cameraOverlay) return; // only drag if outer container
  isDragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartLeft = overlayPos.left;
  dragStartBottom = overlayPos.bottom;
  e.preventDefault();
});
window.addEventListener('mouseup', () => { isDragging = false; });
window.addEventListener('mousemove', (e) => {
  if(!isDragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  overlayPos.left = Math.min(Math.max(dragStartLeft + dx, 0), preview.clientWidth - overlaySize.width);
  overlayPos.bottom = Math.min(Math.max(dragStartBottom - dy, 0), preview.clientHeight - overlaySize.height);
  updateOverlayStyle();
});

// Listen to mouseup to update size after resize (only if enabled)
cameraOverlay.addEventListener('mouseup', () => {
  if(cameraOverlay.style.resize === "none") return;
  const style = window.getComputedStyle(cameraOverlay);
  overlaySize.width = parseInt(style.width);
  overlaySize.height = parseInt(style.height);
});

// Automatically ask for screen and camera as soon as page loads (instead of waiting for button)
async function initializeStreams() {
  try {
    // First, prompt for screen capture immediately
    screenStream = await navigator.mediaDevices.getDisplayMedia({
      video: { frameRate: 60 }
    });

    // Then get selected camera and mic
    const cameraId = videoSelect.value;
    cameraStream = await navigator.mediaDevices.getUserMedia({
      video: { deviceId: cameraId ? { exact: cameraId } : undefined, width: 640, height: 360 },
      audio: false
    });
    cameraVideo.srcObject = cameraStream;

    const audioId = audioSelect.value;
    try {
      micStream = await navigator.mediaDevices.getUserMedia({
        audio: { deviceId: audioId ? { exact: audioId } : undefined }
      });
    } catch (e) {
      console.warn("Mic access failed:", e);
      micStream = null;
    }

    resolutionInfo.textContent = `Screen capture active at 60 FPS. Camera active.`;
    statusEl.textContent = "Ready to record. Press Start Recording.";

    // Enable overlay interaction before recording
    setOverlayInteraction(true);
  } catch (e) {
    console.error("Error initializing streams:", e);
    statusEl.textContent = "Error initializing streams: " + e.message;
  }
}

// Modify startRec onclick to disable interaction after starting recording
startRec.onclick = async () => {
  startRec.disabled = true;
  stopRec.disabled = false;
  downloadContainer.innerHTML = "";
  statusEl.textContent = "Starting streams...";
  
  await initializeStreams();

  statusEl.textContent = "Combining streams...";
  const combinedStream = createCombinedStream();

  let mimeType = getSupportedMimeType();
  if (!mimeType) {
    statusEl.textContent = "No supported MIME type for recording found.";
    startRec.disabled = false;
    stopRec.disabled = true;
    return;
  }
  statusEl.textContent = `Recording with MIME type: ${mimeType}`;

  recordedChunks = [];
  try {
    recorder = new MediaRecorder(combinedStream, { mimeType });
  } catch (e) {
    console.error("Failed to create MediaRecorder:", e);
    statusEl.textContent = "Failed to start recorder: " + e.message;
    startRec.disabled = false;
    stopRec.disabled = true;
    return;
  }

  recorder.ondataavailable = (e) => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };
  recorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `screen_camera_recording.${mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
    a.textContent = "Download Recording";
    a.className = "download-link";
    downloadContainer.appendChild(a);
    statusEl.textContent = "Recording stopped. Ready to start a new recording.";
  };

  recorder.start();
  statusEl.textContent = "Recording started. Press Stop Recording when done.";

  // Disable overlay interaction once recording starts
  setOverlayInteraction(false);
};

// On page load: populate devices and initialize streams (with prompt)
(async () => {
  await populateDevices();
  await initializeStreams();
})();
