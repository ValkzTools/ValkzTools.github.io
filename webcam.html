<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Screen + Webcam Recorder</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #222; color: #eee;
      display: flex; flex-direction: column; align-items: center;
      height: 100vh; overflow: hidden;
    }
    h1 {
      margin-bottom: 12px;
    }
    #controls {
      margin-bottom: 12px;
      display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;
    }
    select, button {
      font-size: 1rem; padding: 8px 12px; border-radius: 6px; border: none;
    }
    #status {
      margin-top: 8px; min-height: 20px;
      text-align: center;
    }
    #previewContainer {
      position: relative;
      width: 960px;
      height: 540px;
      background: black;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 12px #000;
      user-select: none;
    }
    #screenPreview {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #111;
      display: block;
    }
    #cameraOverlay {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 320px;
      height: 180px;
      border: 2px solid #fff;
      border-radius: 8px;
      background: black;
      cursor: move;
      box-sizing: border-box;
      user-select: none;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #cameraVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none; /* prevent direct interaction */
      user-select: none;
    }
    #resizeHandle {
      position: absolute;
      width: 20px;
      height: 20px;
      bottom: 0;
      right: 0;
      background: white;
      opacity: 0.7;
      cursor: se-resize;
      user-select: none;
      border-bottom-right-radius: 8px;
    }
    #downloadLink {
      margin-top: 12px;
      display: block;
      font-weight: bold;
      color: #4caf50;
      text-decoration: none;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Screen + Webcam Recorder</h1>

  <div id="controls">
    <label>
      Camera:
      <select id="videoSource"></select>
    </label>
    <label>
      Microphone:
      <select id="audioSource"></select>
    </label>
    <button id="startRec">Start Recording</button>
    <button id="stopRec" disabled>Stop Recording</button>
  </div>
  <div id="status">Loading devices...</div>

  <div id="previewContainer">
    <video id="screenPreview" autoplay muted playsinline></video>
    <div id="cameraOverlay" tabindex="0">
      <video id="cameraVideo" autoplay muted playsinline></video>
      <div id="resizeHandle"></div>
    </div>
  </div>

  <a id="downloadLink" style="display:none" download>Download Recording</a>

  <script>
    const videoSelect = document.getElementById("videoSource");
    const audioSelect = document.getElementById("audioSource");
    const startRec = document.getElementById("startRec");
    const stopRec = document.getElementById("stopRec");
    const statusEl = document.getElementById("status");
    const screenPreview = document.getElementById("screenPreview");
    const cameraVideo = document.getElementById("cameraVideo");
    const cameraOverlay = document.getElementById("cameraOverlay");
    const resizeHandle = document.getElementById("resizeHandle");
    const downloadLink = document.getElementById("downloadLink");
    const previewContainer = document.getElementById("previewContainer");

    let screenStream = null;
    let cameraStream = null;
    let micStream = null;
    let recorder = null;
    let recordedChunks = [];

    // Overlay position and size
    let overlayPos = { left: 10, bottom: 10 };
    let overlaySize = { width: 320, height: 180 };

    function updateOverlayPositionAndSize() {
      cameraOverlay.style.left = overlayPos.left + "px";
      cameraOverlay.style.bottom = overlayPos.bottom + "px";
      cameraOverlay.style.width = overlaySize.width + "px";
      cameraOverlay.style.height = overlaySize.height + "px";
    }
    updateOverlayPositionAndSize();

    // Dragging overlay logic
    let dragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragStartLeft = 0, dragStartBottom = 0;

    cameraOverlay.addEventListener('mousedown', (e) => {
      if (e.target === resizeHandle) return; // ignore drag start on resize handle
      dragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragStartLeft = overlayPos.left;
      dragStartBottom = overlayPos.bottom;
      e.preventDefault();
    });
    window.addEventListener('mouseup', () => {
      dragging = false;
    });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      const containerRect = previewContainer.getBoundingClientRect();

      // Calculate new left/bottom, clamp within preview container
      let newLeft = dragStartLeft + dx;
      let newBottom = dragStartBottom - dy; // y inverted because bottom positioning

      newLeft = Math.max(0, Math.min(newLeft, containerRect.width - overlaySize.width));
      newBottom = Math.max(0, Math.min(newBottom, containerRect.height - overlaySize.height));

      overlayPos.left = newLeft;
      overlayPos.bottom = newBottom;
      updateOverlayPositionAndSize();
    });

    // Resizing overlay logic
    let resizing = false;
    let resizeStartX = 0, resizeStartY = 0;
    let resizeStartWidth = 0, resizeStartHeight = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
      resizing = true;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartWidth = overlaySize.width;
      resizeStartHeight = overlaySize.height;
      e.preventDefault();
      e.stopPropagation();
    });
    window.addEventListener('mouseup', () => {
      resizing = false;
    });
    window.addEventListener('mousemove', (e) => {
      if (!resizing) return;
      const dx = e.clientX - resizeStartX;
      const dy = e.clientY - resizeStartY;
      const containerRect = previewContainer.getBoundingClientRect();

      let newWidth = resizeStartWidth + dx;
      let newHeight = resizeStartHeight + dy;

      // Clamp size - minimum 100x60, max within container
      newWidth = Math.max(100, Math.min(newWidth, containerRect.width - overlayPos.left));
      newHeight = Math.max(60, Math.min(newHeight, containerRect.height - overlayPos.bottom));

      overlaySize.width = newWidth;
      overlaySize.height = newHeight;
      updateOverlayPositionAndSize();
    });

    // Populate devices
    async function populateDevices() {
      try {
        await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
      } catch {}

      const devices = await navigator.mediaDevices.enumerateDevices();
      videoSelect.innerHTML = "";
      audioSelect.innerHTML = "";

      devices.forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;

        if (device.kind === 'videoinput') {
          option.text = device.label || `Camera ${videoSelect.length + 1}`;
          videoSelect.appendChild(option);
        } else if (device.kind === 'audioinput') {
          option.text = device.label || `Microphone ${audioSelect.length + 1}`;
          audioSelect.appendChild(option);
        }
      });

      if (videoSelect.options.length > 0) videoSelect.selectedIndex = 0;
      if (audioSelect.options.length > 0) audioSelect.selectedIndex = 0;
    }

    // Start preview streams (screen + camera + mic)
    async function startPreviewStreams() {
      try {
        if (screenStream) {
          screenStream.getTracks().forEach(t => t.stop());
          screenStream = null;
        }
        if (cameraStream) {
          cameraStream.getTracks().forEach(t => t.stop());
          cameraStream = null;
        }
        if (micStream) {
          micStream.getTracks().forEach(t => t.stop());
          micStream = null;
        }

        screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: 60 }, audio: true });
        screenPreview.srcObject = screenStream;

        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: videoSelect.value ? { exact: videoSelect.value } : undefined, width: 640, height: 360 },
          audio: false
        });
        cameraVideo.srcObject = cameraStream;

        try {
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: audioSelect.value ? { exact: audioSelect.value } : undefined }
          });
        } catch (err) {
          micStream = null; // mic optional
        }

        statusEl.textContent = "Preview started. Ready to record.";
      } catch (err) {
        statusEl.textContent = "Error accessing media devices: " + err.message;
        console.error(err);
      }
    }

    // Combine streams (screen + camera + mic audio)
    function createCombinedStream() {
      // Canvas to combine streams
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size same as preview container
      canvas.width = previewContainer.clientWidth;
      canvas.height = previewContainer.clientHeight;

      // Get video tracks for camera and screen
      const screenVideoTrack = screenStream.getVideoTracks()[0];
      const cameraVideoTrack = cameraStream.getVideoTracks()[0];

      // Create MediaStreamTracks from canvas
      const canvasStream = canvas.captureStream(60); // 60fps

      // Combine audio tracks: screen audio + mic audio
      const audioTracks = [];
      if (screenStream.getAudioTracks().length > 0) {
        audioTracks.push(screenStream.getAudioTracks()[0]);
      }
      if (micStream && micStream.getAudioTracks().length > 0) {
        audioTracks.push(micStream.getAudioTracks()[0]);
      }

      // Draw loop
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw screen video full size
        const screenVideoSettings = screenVideoTrack.getSettings();
        // For simplicity, fill canvas fully with screen video
        ctx.drawImage(screenPreview, 0, 0, canvas.width, canvas.height);

        // Draw camera video on overlay position and size
        ctx.drawImage(cameraVideo, overlayPos.left, canvas.height - overlayPos.bottom - overlaySize.height, overlaySize.width, overlaySize.height);

        requestAnimationFrame(draw);
      }
      draw();

      // Combine canvas video and audio tracks into one stream
      const combinedStream = new MediaStream();
      canvasStream.getVideoTracks().forEach(track => combinedStream.addTrack(track));
      audioTracks.forEach(track => combinedStream.addTrack(track));

      return combinedStream;
    }

    // Get supported MIME type for recording
    function getSupportedMimeType() {
      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) return 'video/webm;codecs=vp9';
      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) return 'video/webm;codecs=vp8';
      if (MediaRecorder.isTypeSupported('video/webm')) return 'video/webm';
      return '';
    }

    // Recording logic
    startRec.onclick = async () => {
      startRec.disabled = true;
      stopRec.disabled = false;
      downloadLink.style.display = 'none';
      downloadLink.href = '';
      downloadLink.textContent = '';
      statusEl.textContent = "Starting streams...";
      await startPreviewStreams();

      statusEl.textContent = "Combining streams...";
      const combinedStream = createCombinedStream();

      let mimeType = getSupportedMimeType();
      if (!mimeType) {
        statusEl.textContent = "No supported MIME type found for recording.";
        startRec.disabled = false;
        stopRec.disabled = true;
        return;
      }
      statusEl.textContent = `Recording with MIME type: ${mimeType}`;

      recordedChunks = [];
      try {
        recorder = new MediaRecorder(combinedStream, { mimeType });
      } catch (e) {
        statusEl.textContent = "Failed to start recorder: " + e.message;
        startRec.disabled = false;
        stopRec.disabled = true;
        return;
      }

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: mimeType });
        const url = URL.createObjectURL(blob);
        downloadLink.href = url;
        downloadLink.download = `screen_camera_recording.${mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
        downloadLink.textContent = "Download Recording";
        downloadLink.style.display = 'block';
        statusEl.textContent = "Recording stopped. Ready for a new recording.";
      };

      recorder.start();
      statusEl.textContent = "Recording started. Press Stop Recording when done.";
    };

    stopRec.onclick = () => {
      if (recorder && recorder.state === "recording") {
        recorder.stop();
      }
      startRec.disabled = false;
      stopRec.disabled = true;

      // Stop all streams
      if (screenStream) {
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
      }
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
        cameraVideo.srcObject = null;
      }
      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      screenPreview.srcObject = null;

      statusEl.textContent = "Preview stopped.";
    };

    // Change video or audio source dropdown triggers preview restart
    videoSelect.onchange = startPreviewStreams;
    audioSelect.onchange = startPreviewStreams;

    // On load, populate devices and start preview
    (async () => {
      await populateDevices();
      await startPreviewStreams();
      statusEl.textContent = "Ready to record.";
    })();
  </script>
</body>
</html>
